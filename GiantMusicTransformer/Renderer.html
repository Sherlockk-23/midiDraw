<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>MIDI Renderer</title>
	<script src="libs/Tone.js"></script>
	<script src="libs/Midi.min.js"></script>
	<script src="libs/soundfont-player.min.js"></script>
	<style>
		canvas { border: 1px solid #ccc; display: block; margin-top: 10px; }
		#controls { margin-top: 10px; }
	</style>
</head>
<body>
	<input type="file" id="imageInput" accept="image/*" />
	<button id="clearBtn">Clear</button>
	<button id="initBtn">Init</button>
	<canvas id="drawCanvas" width="1000" height="400" style="border:1px solid #ccc; cursor: crosshair;"></canvas>
	<input type="file" id="fileInput" accept=".mid" />
	<div id="controls">
		<button onclick="runLocalModelAndDisplay()">Generate</button>
		<button id="playBtn">Play</button>
		<button id="pauseBtn">Pause</button>
	</div>
	<div id="zoomControls">
		<button onclick="zoomIn()">+</button>
		<button onclick="zoomOut()">−</button>
	</div>
	<div id="canvasContainer" style="overflow: auto">
		<canvas id="pianoRoll" width="1000" height="696"></canvas>
	</div>

	<script>
		const drawCanvas = document.getElementById("drawCanvas");
		const drawCtx = drawCanvas.getContext("2d");
		const input = document.getElementById("imageInput");

		let drawing = false;

		// 设置绘图样式
		drawCtx.lineWidth = 4;
		drawCtx.lineCap = "round";
		drawCtx.strokeStyle = "#000";

		drawCanvas.addEventListener("mousedown", (e) => {
			drawing = true;
			const { x, y } = getMousePos(drawCanvas, e);
			drawCtx.beginPath();
			drawCtx.moveTo(x, y);
		});

		drawCanvas.addEventListener("mousemove", (e) => {
			if (!drawing) return;
			const { x, y } = getMousePos(drawCanvas, e);
			drawCtx.lineTo(x, y);
			drawCtx.stroke();
		});

		drawCanvas.addEventListener("mouseup", () => {
			drawing = false;
		});

		drawCanvas.addEventListener("mouseleave", () => {
			drawing = false;
		});

		document.getElementById("clearBtn").addEventListener("click", () => {
			drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
		});

		// document.getElementById("initBtn").addEventListener("click", () => {
		// 	await loadModel();
		// });

		document.getElementById("initBtn").addEventListener("click", async () => {
			try {
				msg = await loadModel();
				alert("Model initialized successfully!");
				console.log(msg);
			} catch (error) {
				alert("Failed to initialize model: " + error.message);
			}
		});

		function getMousePos(drawCanvas, evt) {
			const rect = drawCanvas.getBoundingClientRect();
			return {
				x: evt.clientX - rect.left,
				y: evt.clientY - rect.top
			};
		}

		input.addEventListener("change", (e) => {
			const file = e.target.files[0];
			if (!file) return;

			const reader = new FileReader();
			reader.onload = function(event) {
				const img = new Image();
				img.onload = function() {
					drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
					const scale = Math.min(
						drawCanvas.width / img.width,
						drawCanvas.height / img.height
					);
					const imgWidth = img.width * scale;
					const imgHeight = img.height * scale;
					//const x = (drawCanvas.width - imgWidth) / 2;
					const x = 0;
					const y = (drawCanvas.height - imgHeight) / 2;
					drawCtx.drawImage(img, x, y, imgWidth, imgHeight);
				};
				img.src = event.target.result;
			};
			reader.readAsDataURL(file);
		});




		const fileInput = document.getElementById("fileInput");
		const canvas = document.getElementById("pianoRoll");
		const ctx = canvas.getContext("2d");
		const playBtn = document.getElementById("playBtn");
		const pauseBtn = document.getElementById("pauseBtn");
		
		const halfStepHeight = 8;
		const audioCtx = new AudioContext();
		const instruments = {};
		const playingNotes = [];

		let midi = null;
		let synth = null;
		let isPlaying = false;
		let startTime = 0;
		let elapsedWhenPaused = 0;
		let animationFrameId = null;
		let zoomLevel = 1.0;
		const ZOOM_STEP = 0.1;

		function applyCanvasScale() {
			const canvas = document.getElementById("pianoRoll");
			canvas.style.transform = `scale(${zoomLevel})`;
			canvas.style.transformOrigin = "top left";
		}

		function zoomIn() {
			zoomLevel = Math.min(zoomLevel + ZOOM_STEP, 10);
			//drawMidi(midi, elapsedWhenPaused);
			applyCanvasScale();
		}

		function zoomOut() {
			zoomLevel = Math.max(zoomLevel - ZOOM_STEP, 0.2);
			//drawMidi(midi, elapsedWhenPaused);
			applyCanvasScale();
		}

		async function loadModel() {
			try {
				const response = await fetch("http://localhost:5000/load-model");
				console.log(response);
				if (!response.ok) {
					throw new Error("Failed to load model");
				}
				console.log("Model loaded successfully");
			} catch (error) {
				console.error("Error loading model:", error);
			}
			try {
				const response = await fetch("http://localhost:5000/load-seed-midi");
				console.log(response);
				if (!response.ok) {
					throw new Error("Failed to load seed");
				}
				console.log("seed loaded successfully");
			} catch (error) {
				console.error("Error loading seed:", error);
			}
		}

		async function runLocalModelAndDisplay() {
			const canvas = document.getElementById("drawCanvas");
			const imageData = canvas.toDataURL("image/png");
			const response = await fetch("http://localhost:5000/generate-midi", {
				method: "POST",
				headers: {
					"Content-Type": "application/json"
				},
				body: JSON.stringify({ image: imageData })
			});
			console.log("after generation", response);
			if (!response.ok) {
				console.error("Failed to fetch MIDI from server");
				return;
			}
			const midiBlob = await response.blob();
			const arrayBuffer = await midiBlob.arrayBuffer();
			midi = new Midi(arrayBuffer);
			elapsedWhenPaused = 0;
			drawMidi(midi, 0);
		}

		fileInput.addEventListener("change", async (e) => {
			const file = e.target.files[0];
			if (!file) return;
			const arrayBuffer = await file.arrayBuffer();
			midi = new Midi(arrayBuffer);
			drawMidi(midi);
		});

		function drawMidi(midi, currentTime = 0) {
			ctx.clearRect(0, 0, canvas.width, canvas.height);

			const notes = midi.tracks.flatMap(track => track.notes);
			const maxTime = Math.max(...notes.map(n => n.time + n.duration));
			const maxNote = 108, minNote = 21;
			const pitchRange = maxNote - minNote;

			canvas.height = pitchRange * halfStepHeight;
			canvas.width = maxTime * halfStepHeight * 5;

			const programColorMap = {};
			let colorIndex = 0;
			const colorPalette = [
				"#e74c3c", "#3498db", "#2ecc71", "#f1c40f",
				"#9b59b6", "#1abc9c", "#e67e22", "#34495e"
			];

			midi.tracks.forEach((track, tIdx) => {
				const program = track.instrument.number ?? tIdx;
				const color = programColorMap[program] ?? (programColorMap[program] = colorPalette[colorIndex++ % colorPalette.length]);

				for (const note of track.notes) {
					const x = (note.time / maxTime) * canvas.width;
					const w = (note.duration / maxTime) * canvas.width;
					const y = (canvas.height - ((note.midi - minNote) / pitchRange) * canvas.height);
					const h = 6;
					ctx.fillStyle = color;
					ctx.fillRect(x, y, w, h);
				}
			});

			// Draw red time line
			const lineX = (currentTime / maxTime) * canvas.width;
			ctx.strokeStyle = "red";
			ctx.lineWidth = 2;
			ctx.beginPath();
			ctx.moveTo(lineX, 0);
			ctx.lineTo(lineX, canvas.height);
			ctx.stroke();
		}

		function schedulePlayback() {
			synth = new Tone.PolySynth().toDestination();
			const now = Tone.now();

			midi.tracks.forEach(track => {
				track.notes.forEach(note => {
					if (note.time >= elapsedWhenPaused && note.duration > 0) {
						synth.triggerAttackRelease(
							note.name,
							note.duration,
							now + (note.time - elapsedWhenPaused),
							note.velocity
						);
					}
				});
			});
		}

		function animate() {
			if (!isPlaying) return;

			const now = Tone.now();
			const currentTime = now - startTime + elapsedWhenPaused;

			drawMidi(midi, currentTime);

			animationFrameId = requestAnimationFrame(animate);
		}

		playBtn.addEventListener("click", async () => {
			if (!midi) return;

			await Tone.start();

			if (!isPlaying) {
				isPlaying = true;
				startTime = Tone.now();
				Tone.Transport.start("+0.1", elapsedWhenPaused);
				schedulePlayback();
				animate();
			}
		});

		pauseBtn.addEventListener("click", () => {
			if (isPlaying) {
				isPlaying = false;
				Tone.Transport.pause();
				elapsedWhenPaused += Tone.now() - startTime;
				if (synth) synth.dispose();
				cancelAnimationFrame(animationFrameId);
			}
		});

		canvas.addEventListener("click", (e) => {
			if (!midi) return;

			const rect = canvas.getBoundingClientRect();
			const clickX = e.clientX - rect.left;
			const canvasWidth = canvas.width;

			const maxTime = Math.max(...midi.tracks.flatMap(t => t.notes.map(n => n.time + n.duration)));
			const targetTime = (clickX / canvasWidth) * maxTime;

			// Stop and reset
			isPlaying = false;
			Tone.Transport.stop();
			Tone.Transport.cancel();
			if (synth) synth.dispose();
			cancelAnimationFrame(animationFrameId);

			elapsedWhenPaused = targetTime;
			drawMidi(midi, elapsedWhenPaused);
		});
	</script>
</body>
</html>
